# 未穿反光服检测任务判定逻辑说明

## 背景
实现一个基于视频流的未穿反光服（vest）检测任务。在实时视频中对人员进行检测、跟踪与属性判定，并在满足违规条件时发送告警消息。由于反光服分类模型在单帧上的稳定性有限，若直接基于单帧结果进行判定，容易产生误报或类别抖动问题，因此需要设计一套稳定、可解释、工程可落地的判定逻辑。

## 目标
- 在视频流中稳定、准确地识别**未穿反光服的人员**
- 降低因模型不稳定、单帧误判带来的误报率
- 确保告警触发逻辑具备时序一致性和可解释性
- 支持在 ROI 场景下的定点监管需求
- 判定逻辑可复用、可调参、易于维护

## 约束
- 不允许仅基于单帧分类结果直接触发告警
- 不允许对 ROI 区域外的目标进行违规判定
- 必须基于目标跟踪（Track ID）进行时序判定
- 告警策略需具备参数化能力（阈值、窗口大小等）
- 未穿反光服属于高风险负类，判定策略应保守：宁可慢判不可错判，宁可不报不可乱报

## 输出要求
- 清晰说明整体处理流程与各阶段逻辑
- 明确未穿反光服违规的最终判定条件
- 给出基于 Track ID 的历史投票判定机制
- 提出有助于提升稳定性和工程效果的合理建议

---

## 任务判定流程说明

### 1. 人员目标检测
- 对视频流中的每一帧执行 YOLO 目标检测
- 从检测结果中筛选出 `person` 类别的目标
- 获取每个目标的：
  - Bounding Box（x1, y1, x2, y2）
  - 置信度 score

### 2. 置信度与 ROI 区域过滤
- 若人员检测置信度低于设定阈值，则忽略该目标
- 对满足置信度要求的目标，判断其中心点是否位于预先配置的 ROI 区域内
- 若目标的检测框中心点不在任何 ROI 区域内，则不进入后续逻辑

### 3. 人员目标跟踪
- 对通过 ROI 校验的人员目标进行多目标跟踪
- 为每个目标分配唯一的 `track_id`
- 后续所有判定逻辑均以 `track_id` 作为时序关联的唯一标识

### 4. 有效帧过滤与反光服分类

#### 4.1 有效帧判定
不是所有帧都应该进入分类流程，以下情况应丢弃分类结果：
- bbox 面积 < 最小阈值

#### 4.2 反光服分类
- 根据检测到的 bounding box，从原始帧中裁剪人员 ROI 图像
- 将裁剪后的图像输入反光服分类模型进行推理
- 分类模型输出目标是否属于 `vest` 类（穿反光服 `vest` / 未穿反光服 `non-vest`）

### 5. 基于 Track ID 的判定机制（投票 + 锁定）

为提高分类稳定性并降低误报率，引入**投票 + 锁定双机制**进行最终类别判定。投票机制负责违规判定，锁定机制负责类别稳定，两者协同工作、互不冲突。

#### 核心参数

| 参数 | 含义 | 默认值 |
|------|------|--------|
| history_window_size | 投票窗口大小（分类历史队列长度） | 20s = 40 帧 |
| violation_threshold_count | 违规阈值：窗口内 non-vest 帧数 | 14s = 28 帧 |
| lock_trigger | 锁定触发条件：连续相同投票结果的帧数 | 15s = 30 帧 |
| lock_duration | 锁定持续时间 | 15s = 30 帧 |

#### 5.1 状态数据结构（per track_id）

```python
{
    "classification_history": deque(maxlen=history_window_size),  # 实际分类结果队列（仅非锁定期间更新）
    "voting_streak_class": "",                   # 当前连续投票结果类别
    "voting_streak_count": 0,                    # 连续投票结果帧数
    "locked_class": "",                          # 锁定类别（""=未锁定）
    "lock_remaining": 0,                         # 锁定剩余帧数
}
```

#### 5.2 投票机制（违规判定）

- 对每个 `track_id` 维护最近 history_window_size 帧的**实际分类历史队列**（仅非锁定期间更新）
- 每帧对队列中的分类结果做**多数投票**，得到 `voting_class`
- 若队列中 non-vest 计数 >= violation_threshold_count → 触发违规告警

#### 5.3 锁定机制（类别稳定）

- **锁定条件**：投票结果（`voting_class`）连续 lock_trigger 帧为同一类别
- **锁定效果**：将该类别锁定 lock_duration 帧，锁定期间不再更新分类历史与投票
- **锁定到期后**：清空历史队列，重置投票连续计数，开启新判定周期

#### 5.4 投票与锁定的协同关系

- 锁定条件基于投票结果的连续稳定性，是投票的**下游判定**
- 每帧先做违规检查，再做锁定检查，保证**违规告警优先**
- 锁定期间分类模型仍运行（获取 `actual_class` 用于可视化），但不参与投票
- 锁定到期后历史清空 → 新周期，两个机制互不干扰

#### 5.5 每帧输出（用于可视化）—— 三元组

```
(actual_class, voting_class, locked_class)
```

| 字段 | 含义 | 说明 |
|------|------|------|
| `actual_class` | 当前帧模型实际分类结果 | 每帧都有值 |
| `voting_class` | 投票后的类别 | 锁定期间为 `""` |
| `locked_class` | 锁定后的类别 | 未锁定时为 `""` |

#### 5.6 完整判定流程

```
每帧处理:

1. 运行分类模型 → actual_class

2. 若已锁定（lock_remaining > 0）:
   a. lock_remaining -= 1
   b. voting_class = ""（锁定期间无投票）
   c. 若 lock_remaining == 0（锁定到期）:
      - 清空 classification_history
      - 重置 voting_streak_class = "", voting_streak_count = 0
      - locked_class = ""
      （进入新判定周期）
   d. 输出 (actual_class, voting_class="", locked_class)
   e. 结束本帧

3. 若未锁定:
   a. 将 actual_class 加入 classification_history

   b. 投票: voting_class = classification_history 中的多数类别

   c. 更新投票连续计数:
      - 若 voting_class == voting_streak_class → voting_streak_count += 1
      - 否则 → voting_streak_class = voting_class, voting_streak_count = 1

   d. 违规检查:
      - non_vest_count = classification_history 中 non-vest 的计数
      - 若 non_vest_count >= violation_threshold_count → 触发违规告警（受冷却时间约束）

   e. 锁定检查:
      - 若 voting_streak_count >= lock_trigger:
        - locked_class = voting_streak_class
        - lock_remaining = lock_duration

   f. 输出 (actual_class, voting_class, locked_class)
```

### 6. 告警触发
- 违规告警在每帧的**锁定检查之前**触发，保证告警优先级高于锁定
- 当 `classification_history` 中 non-vest 计数 >= violation_threshold_count 时，发送未穿反光服违规告警消息
- 同一 `track_id` 可设置告警冷却时间（`cooldown_period`），避免重复告警

---

## 合理建议

1. **历史窗口与阈值解耦**
   - 投票窗口大小 N 与违规触发阈值应独立配置，便于不同场景调优

2. **引入"状态确认帧"机制**
   - 在目标刚出现的前若干帧内不参与违规判定，减少初始误判
   - 推荐：`min_confirm = 5~10`

3. **结合目标可见性条件**
   - 对遮挡严重、ROI 面积过小的目标可暂缓分类判定
   - 建议设置最小 bbox 面积阈值和人体高度比例阈值

4. **支持动态参数调整**
   - 针对不同摄像头、光照条件，支持在线调整目标检测、图像分类得分阈值参数

5. **告警与判定解耦**
   - 判定逻辑只负责输出"是否违规"
   - 告警模块单独处理告警频率、合并策略与消息发送

---

## 总结
通过"目标检测 + ROI 过滤 + 目标跟踪 + 分类模型 + 基于 Track ID 的投票 + 锁定双机制"，该未穿反光服检测逻辑能够有效抑制模型抖动带来的误判问题。投票机制负责违规判定，锁定机制负责类别稳定，两者协同工作、互不冲突，在保证实时性的同时显著提升整体系统的稳定性与工程可靠性。

---

## 违规检测关键参数配置示例

```python
CONFIG = {
    # 检测参数
    "detect_conf": 0.6,           # YOLO 检测置信度阈值
    "nms_iou": 0.45,              # NMS IoU 阈值

    # 跟踪参数
    "max_age": 30,                # 跟踪目标最大丢失帧数
    "min_hits": 3,                # 最小连续检测帧数
    "min_confirm": 5,             # Track 稳定确认帧数
    "max_missing": 3,             # Track 丢失容忍帧数

    # 有效帧过滤参数
    "min_bbox_area": 1000,        # 最小 bbox 面积

    # 分类参数
    "classify_conf": 0.7,         # 分类置信度阈值

    # 投票 + 锁定参数
    "history_window_size": 40,         # 投票窗口大小（帧数，20s × 2fps = 40）
    "violation_threshold_count": 28,   # 违规阈值：窗口内 non-vest 帧数（14s × 2fps = 28）
    "lock_trigger": 30,                # 锁定触发条件：连续相同投票结果的帧数（15s × 2fps = 30）
    "lock_duration": 30,               # 锁定持续时间（帧数，15s × 2fps = 30）

    # 告警参数
    "cooldown_period": 60,             # 告警冷却时间(秒)
}
```
